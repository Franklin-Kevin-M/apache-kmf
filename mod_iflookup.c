/* 
**  mod_iflookup.c -- Apache binary search fixed width file
**  [Autogenerated via ``apxs -n iflookup -g'']
**
**    $ lynx -mime_header http://localhost/kevin 
**
**    The sample page from mod_iflookup.c

Arguments in the iflookup conf file and their usage:

Example Usage:
			<Location /iflookup>
					SetHandler iflookup
					indexFile "/home/kevin/iflookup/index.dat"
					dataFile "/home/kevin/iflookup/data.dat"
					indexRecordLength 8
					offsetStart 2
					offsetLength 2
					indexKeyStart 0
					indexKeyLength 1
					dataLengthStart 5
					dataLengthLength 3
					dataOverrideLength 11
					NoDups True
			</Location>

Sample Index:
1 11 11
1 11 11
1 11 11
3 33 11
4 22 11
9 00 11
-
Sample Data:
9999999999
1111111111
4444444444
3333333333
-
Description:
	This module is intended to serve records from files.  It has intenionally
	been left database free.  It has 
indexFile:
	Index file MUST be sorted by key if that isn't the case everything is for no
	reason. It also must be fixed width which means each record MUST be the same
	length.  File can be anywhere, may I suggest local?

dataFile:
	This file does NOT have to be sorted and can be anywhere.  No real concerns 
	other that read access.

indexRecordLength:
	The length of the record in the index file (including LF or CR/LF)
	
indexKeyStart:
	Helps to define indexFile, this is the start position of the key field.
	
indexKeyLength:
	Helps to define indexFile, this is the key length in the indexFile.

offsetStart:
	Helps to define indexFile, this is the position of the offset of the record 
	in the data file.  
	
offsetLength:
	Helps to define indexFile, this is the length of the offset of the record in 
	the data file.


dataLengthStart: (not used if a dataOverrideLength is provided)
	Helps to define indexFile, this is the position of the record in the data 
	file.  
	
dataLengthLength: (not used if a dataOverrideLength is provided)
	Helps to define indexFile, this is the length of the record in the data file.

dataOverrideLength:
	If every record in the dataFile is exactly the same you can provide that 
	info here instead of having a dataLength in the index file.

NoDups:
	Include duplicate records or not.  Default to no (which means include dups), 
	If you don't want dups set it to one of the following:
		T, True, Y, Yes, 1

*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "util_script.h"

static int iflookup_handler(request_rec *r);
static void iflookup_register_hooks(apr_pool_t *p) ;
static void *create_dir_conf(apr_pool_t *pool, char *context) ;
static int searchFile( const char *key, request_rec *r, int debug ) ;

typedef struct {
	int indexRecLength ;
	int indexKeyLength ;
	int indexKeyStart ;
	int noDuplicates ;
	int offsetStart ;
	int offsetLength ;
	int dataLengthStart ;
	int dataLengthLength ;
	int dataOverrideLength ;
	char indexFile[256] ;
	char dataFile[256] ;
	char resultPreText[256] ;
	char resultPostText[256] ;
	char recordPreText[256] ; 
	char recordPostText[256] ;
} iflookup_config ;

/* Handler for the "iflookupFile" directive */
const char *iflookup_set_resultPreText(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->resultPreText, arg ) ;	
    return NULL;
}
const char *iflookup_set_resultPostText(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->resultPostText, arg ) ;	
    return NULL;
}
const char *iflookup_set_recordPreText(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->recordPreText, arg ) ;	
    return NULL;
}
const char *iflookup_set_recordPostText(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->recordPostText, arg ) ;	
    return NULL;
}
const char *iflookup_set_indexFile(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->indexFile, arg ) ;	
    return NULL;
}
const char *iflookup_set_dataFile(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    strcpy( kc->dataFile, arg ) ;	
    return NULL;
}
const char *iflookup_set_no_dups(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
	kc->noDuplicates = 0 ;
	if ( arg != NULL ) 
		if ( ( arg[0] == 'Y' ) || ( arg[0] == 'y' ) || ( arg[0] == 'T' ) || 
				( arg[0] == 't' ) || ( arg[0] == '1' ) )
			kc->noDuplicates = 1 ;
    return NULL;
}
const char *iflookup_set_indexRecordLength(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->indexRecLength = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_indexKeyLength(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->indexKeyLength = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_indexKeyStart(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->indexKeyStart = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_offsetLength(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->offsetLength = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_offsetStart(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->offsetStart = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_dataLengthLength(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->dataLengthLength = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_dataLengthStart(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->dataLengthStart = atoi( arg ) ;
    return NULL;
}
const char *iflookup_set_overrideLength(cmd_parms *cmd, void *cfg, const char *arg) {
    iflookup_config *kc = ( iflookup_config *) cfg ;
    kc->dataOverrideLength = atoi( arg ) ;
    return NULL;
}

static const command_rec iflookup_directives[] = {
	AP_INIT_TAKE1( "IndexFile", iflookup_set_indexFile, NULL, ACCESS_CONF, 
			"The path to the index file" ) ,
	AP_INIT_TAKE1( "DataFile", iflookup_set_dataFile, NULL, ACCESS_CONF, 
			"The path to the data file" ) ,
	AP_INIT_TAKE1( "IndexRecordLength", iflookup_set_indexRecordLength, NULL, 
			ACCESS_CONF, "The length of the record" ) ,
	AP_INIT_TAKE1( "IndexKeyStart", iflookup_set_indexKeyStart, NULL, 
			ACCESS_CONF, "The key start position" ) ,
	AP_INIT_TAKE1( "indexKeyLength", iflookup_set_indexKeyLength, NULL, 
			ACCESS_CONF, "The key length" ) ,
	AP_INIT_TAKE1( "OffsetStart", iflookup_set_offsetStart, NULL, ACCESS_CONF, 
			"The offset start position" ) ,
	AP_INIT_TAKE1( "OffsetLength", iflookup_set_offsetLength, NULL, ACCESS_CONF, 
			"The offset length" ) ,
	AP_INIT_TAKE1( "DataOverrideLength", iflookup_set_overrideLength, NULL, 
			ACCESS_CONF, "The Instead of providing the start stop of length everything is same length" ) ,
	AP_INIT_TAKE1( "DataLengthStart", iflookup_set_dataLengthStart, NULL, 
			ACCESS_CONF, "The start of the data length position" ) ,
	AP_INIT_TAKE1( "DataLengthLength", iflookup_set_dataLengthLength, NULL, 
			ACCESS_CONF, "The length of data to read" ) ,
	AP_INIT_TAKE1( "NoDups", iflookup_set_no_dups, NULL, ACCESS_CONF, 
			"Allow dups or not default yes" ) ,
	AP_INIT_TAKE1( "ResultPreText", iflookup_set_resultPreText, NULL, ACCESS_CONF, 
			"Text to put at beginning of result default blank" ) ,
	AP_INIT_TAKE1( "ResultPostText", iflookup_set_resultPostText, NULL, ACCESS_CONF, 
			"Text to put at ending of result default blank" ) ,
	AP_INIT_TAKE1( "RecordPreText", iflookup_set_recordPreText, NULL, ACCESS_CONF, 
			"Text to put at beginning of each record of result default blank" ) ,
	AP_INIT_TAKE1( "RecordPostText", iflookup_set_recordPostText, NULL, ACCESS_CONF, 
			"Text to put at ending of each result default blank" ) ,
	{ NULL }
} ;

static void *create_dir_conf(apr_pool_t *pool, char *context) {
	context = context ? context : "(undefined context)";
	iflookup_config *cfg = apr_pcalloc(pool, sizeof(iflookup_config));
	if(cfg) {
		/* Set some default values */
		strcpy( cfg->indexFile, "/you/need/to/set/this/in/index.dat") ;
		strcpy( cfg->dataFile, "/you/need/to/set/this/in/data.dat") ;
		cfg->indexRecLength = 0 ;
		cfg->indexKeyStart = 0 ;
		cfg->indexKeyLength = 0 ;
		cfg->offsetStart = 0 ;
		cfg->offsetLength = 0 ;
		cfg->dataLengthStart = 0 ;
		cfg->dataLengthLength = 0 ;
		cfg->dataOverrideLength = 0 ;
		cfg->noDuplicates = 0 ;
		cfg->resultPreText[0] = 0 ;
		cfg->resultPostText[0] = 0 ;
		cfg->recordPreText[0] = 0 ; 
		cfg->recordPostText[0] = 0 ;
	}
	return cfg;
}

static void iflookup_register_hooks(apr_pool_t *pool) {
	iflookup_config *cfg = apr_pcalloc(pool, sizeof(iflookup_config));
	if(cfg) {
		strcpy(cfg->indexFile,  "/you/need/to/set/this/in/index.dat" );
		strcpy(cfg->dataFile,  "/you/need/to/set/this/in/data.dat" );
		cfg->indexRecLength = 0 ;
		cfg->indexKeyStart = 0 ;
		cfg->indexKeyLength = 0 ;
		cfg->noDuplicates = 0 ;
		cfg->offsetStart = 0 ;
		cfg->offsetLength = 0 ;
		cfg->dataOverrideLength = 0 ;
		cfg->dataLengthStart = 0 ;
		cfg->dataLengthLength = 0 ;
		cfg->resultPreText[0] = 0 ;
		cfg->resultPostText[0] = 0 ;
		cfg->recordPreText[0] = 0 ; 
		cfg->recordPostText[0] = 0 ;
	}
    ap_hook_handler(iflookup_handler, NULL, NULL, APR_HOOK_LAST);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA iflookup_module = {
    STANDARD20_MODULE_STUFF, 
    create_dir_conf,          /* create per-dir    config structures */
    NULL,                     /* merge  per-dir    config structures */
    NULL,                     /* create per-server config structures */
    NULL,                     /* merge  per-server config structures */
    iflookup_directives,         /* table of config file commands       */
    iflookup_register_hooks      /* register hooks                      */
};

/**********
 *     1. calculate file offset
 *     2. seek to offset
 *     3. read record into input buffer
 *     4. compare record with key return result
 *     RETURN -999 if error
 ***********/
static int grabDataFromFile( request_rec *r, iflookup_config *kconfig, 
		apr_off_t start, apr_off_t nbytesToRead, int debug ) {
	int rc ;
	apr_file_t *dfile ;
	char buffer[1024] ;
	apr_off_t nbytes ;
	nbytes = nbytesToRead ;

	rc = apr_file_open(&dfile, kconfig->dataFile, APR_READ, APR_OS_DEFAULT, r->pool);
	if ( rc == APR_SUCCESS ) {
		apr_file_seek( dfile, APR_SET, &start ) ;
		apr_file_read( dfile, buffer, &nbytes) ;
		buffer[nbytesToRead] = 0 ; 
		if  ( ( !debug ) && ( kconfig->recordPreText[0] != 0 ) )
			ap_rputs( kconfig->recordPreText, r ) ;
		ap_rputs( buffer, r ) ;
		if  ( ( !debug ) && ( kconfig->recordPostText[0] != 0 ) ) 
			ap_rputs( kconfig->recordPostText, r ) ;
		
		apr_file_close(dfile);
	}
	else {
		fprintf(stderr, "ERROR OPENING FILE {%s} %s\n", kconfig->dataFile, 
				strerror(errno) ) ; 
		fflush( stderr ) ;
	}
	return 0 ;
}

static int getAndCheckRecord( request_rec *r, const char *key, 
		iflookup_config *kconfig, apr_file_t *file, 
	apr_off_t recordNumber, apr_off_t maxRecords, int debug, char d ) {
	char buffer[1024] ;
	char sbuf[20] ;
	apr_off_t dataStart ;
	apr_off_t dataLength ;
	apr_off_t seekTo ;
	apr_off_t nbytes ;

	dataStart = 0 ;
	dataLength = 0 ;
	
	/* Sanity checks */
	if ( recordNumber < 0 )
		return -999 ;
	if ( recordNumber > maxRecords )
		return -999 ;

	// 1. calculate the offset
	seekTo = kconfig->indexRecLength * recordNumber ;

	// 2. seek to offset
	apr_file_seek( file, APR_SET, &seekTo ) ;

	// 3. read record into input buffer
	nbytes = kconfig->indexRecLength ;
	apr_file_read( file, buffer, &nbytes) ;
	buffer[kconfig->indexRecLength] = 0 ; 
	// 4. compare record with key
	int comp ;
	comp = memcmp( key, &buffer[kconfig->indexKeyStart], kconfig->indexKeyLength ) ;
	if ( debug ) 
		ap_rprintf( r, "<tr><td>%c</td><td align='right'>%ld</td><td align='right'>%ld</td><td>", 
				d, recordNumber, seekTo ) ;
	if ( ( comp == 0 ) || ( debug ) ) {
		if ( debug ) {
			if ( comp == 0 )
				ap_rputs( "<b>", r ) ;
			ap_rputs( buffer, r ) ; // Intentionally don't run it thru printf
			if ( comp == 0 )
				ap_rputs( "</b>", r ) ;
		}
		memset( sbuf, 0, 20 ) ;
		strncpy( sbuf, &buffer[kconfig->offsetStart], kconfig->offsetLength) ;
		dataStart = atoll( sbuf ) ;
		
		dataLength = kconfig->dataOverrideLength ;
		if ( kconfig->dataOverrideLength == 0 ) {
			memset( sbuf, 0, 20 ) ;
			strncpy( sbuf, &buffer[kconfig->dataLengthStart], kconfig->dataLengthLength) ;
			dataLength = atoll( sbuf ) ;
		}
		if ( debug )
			ap_rprintf( r, "</td><td>%s</td><td align='right'>%ld</td><td align='right'>%ld</td><td>", 
					kconfig->dataFile, dataStart, dataLength ) ;
		if ( comp == 0 )
			ap_rputs( "<b>", r ) ;
		grabDataFromFile( r, kconfig, dataStart, dataLength, debug ) ;
		if ( comp == 0 )
			ap_rputs( "</b>", r ) ;
	}
	
	if ( debug ) 
		ap_rputs( "</td></tr>\n", r ) ;
	return comp ;

}

static int searchFile( const char *key, request_rec *r, int debug ) {
	int rc, exists, seekcount, found, comp ;
	apr_file_t *file ;
	apr_finfo_t finfo ;
	apr_off_t first, last, middle, curpos  ;

	iflookup_config *kconfig = (iflookup_config *) ap_get_module_config(r->per_dir_config, 
			&iflookup_module);
	if (!kconfig) {
		fprintf(stderr, "ERROR RETRIEVING CONFIG \n") ; 
		fflush( stderr ) ;
		return HTTP_NOT_FOUND; /* Return a 404 if not found. */
	}

	/* Figure out if the file we request exists and isn't a directory */
	rc = apr_stat(&finfo, kconfig->indexFile, APR_FINFO_MIN, r->pool);
	if (rc == APR_SUCCESS) {
		exists = ( (finfo.filetype != APR_NOFILE) &&  !(finfo.filetype & APR_DIR));
		if (!exists) {
			fprintf(stderr, "ERROR FILE TYPE NON FILE {%s}\n", kconfig->indexFile ) ; 
			fflush( stderr ) ;
			return HTTP_NOT_FOUND; /* Return a 404 if not found. */
		}
	}
	else {
		fprintf(stderr, "ERROR FILE apr_stat {%s} %s\n", kconfig->indexFile, 
				strerror(errno) ) ; 
		fflush( stderr ) ;
		return HTTP_NOT_FOUND; /* Return a 404 if not found. */
	}

	rc = apr_file_open(&file, kconfig->indexFile, APR_READ, APR_OS_DEFAULT, r->pool);
	if ( rc != APR_SUCCESS ) {
		fprintf(stderr, "ERROR OPENING FILE {%s} %s\n", kconfig->indexFile, 
				strerror(errno) ) ; 
		fflush( stderr ) ;
		return HTTP_NOT_FOUND; /* Return a 404 if not found. */
	}

	/* Print a title and some general information */
	if ( debug ) {
		ap_rprintf(r, "<h2>Binary Searching %s:</h2>", kconfig->indexFile);
		ap_rprintf(r, "<b>Size:</b> %ld bytes, %ld records<br/>", finfo.size, 
				finfo.size / kconfig->indexRecLength );
		ap_rprintf( r, "Binary Searching for %s<br/>\n", key ) ;
	}

	seekcount = 0 ;
	first = 0 ;
	found = 0 ;
	last = finfo.size / kconfig->indexRecLength ;
	middle = (first+last) / 2 ;
	if  ( ( !debug ) && ( kconfig->resultPreText[0] != 0 ) )
		ap_rputs( kconfig->resultPreText, r ) ;
	if ( debug ) {
		ap_rputs( "<table border=1><tr><td>Dir</td><td>Record</td>\n", r ) ;
		ap_rputs( "<td>Offset</td><td>Contents</td><td>DataFile</td>",r ) ;
		ap_rputs( "<td>Start</td><td>Length</td><td>Data</td></tr>\n", r ) ;
	}
	while ( first <= last ) {
		seekcount++ ;
		//apr_file_gets( buffer, kconfig->recLen, file) ;
		comp = getAndCheckRecord( r, key, kconfig, file, middle, last, debug, 'S') ;
		
		//comp = strncmp( key, &buffer[kconfig->keyStart], kconfig->keyLen ) ;
		if ( comp > 0 )
			first = middle + 1 ;
		else if ( comp == 0 ) {
			//strcpy( rb, buffer ) ;
			found = 1 ;
			curpos = middle ;
			if ( kconfig->noDuplicates == 0 ) {
				while ( getAndCheckRecord( r, key, kconfig, file, --curpos, last, debug, 'B' ) == 0 ) {
					found++ ;
					seekcount++ ;
				}
				seekcount++ ;
				curpos = middle ;
				while ( getAndCheckRecord( r, key, kconfig, file, ++curpos, last, debug, 'F' ) == 0 ) {
					found++ ;
					seekcount++ ;
				}
				seekcount++ ;
			}
					
			break ;
		}
		else 
			last = middle -1 ;
		middle = (first + last)/2;
	}
	if ( debug ) {
		ap_rputs( "</table>\n", r ) ;
		ap_rprintf( r, "<b>seek count: %d</b> ", seekcount ) ;
		if ( found )
			ap_rprintf( r, "FOUND %d", found ) ;
		else
			ap_rputs( "NOTFOUND", r ) ;
		ap_rputs( "\n</pre>\n", r ) ;
	}
	apr_file_close(file);
	if  ( ( !debug ) && ( kconfig->resultPostText[0] != 0 ) )
		ap_rputs( kconfig->resultPostText, r ) ;
	return OK ;
}

/* The handler function for our module.
 * This is where all the fun happens!
 */
static int iflookup_handler(request_rec *r) {
	struct timespec start, end ;
	const char *key;
	const char *debugMode;
	int debug, search ;
	clock_gettime( CLOCK_MONOTONIC, &start ) ;

    if (strcmp(r->handler, "iflookup")) 
        return DECLINED;
    
    apr_table_t *GET; 
	ap_args_to_table(r, &GET);

	/* If we were reached through a POST request fail */
	if ( r->method_number != M_GET ) 
		return HTTP_FORBIDDEN ;

	/* Read the data elements */	
	key = apr_table_get(GET, "key");
	if ( !key ) 
		return DECLINED ;

	debug = 0 ;
	debugMode = apr_table_get(GET, "debug");
	if ( debugMode != NULL ) 
		if ( ( debugMode[0] == 'Y' ) || ( debugMode[0] == 'y' ) || ( debugMode[0] == 'T' ) 
				|| ( debugMode[0] == 't' ) || ( debugMode[0] == '1' ) )
			debug = 1 ;

	iflookup_config *kconfig = (iflookup_config *) ap_get_module_config(r->per_dir_config, 
			&iflookup_module);
    
	/* Set the appropriate content type */
	ap_set_content_type(r, "text/html");
	if ( debug ) 
		ap_rputs("<html>", r) ;

	if ( debug ) {
		ap_rprintf( r, "<h2>Config information</h2>\n" ) ;
		ap_rprintf( r, "<table>\n" ) ;
		ap_rprintf( r, "<tr><td>Index File</td><td>%s</td></tr>\n", 
				kconfig->indexFile ) ;
		ap_rprintf( r, "<tr><td>Data File</td><td>%s</td></tr>\n", 
				kconfig->dataFile ) ;
		ap_rprintf( r, "<tr><td>Index recLen</td><td>%d</td></tr>\n", 
				kconfig->indexRecLength ) ;
		ap_rprintf( r, "<tr><td>Index keyStart</td><td>%d</td></tr>\n", 
				kconfig->indexKeyStart ) ;
		ap_rprintf( r, "<tr><td>Index keyLen</td><td>%d</td></tr>\n", 
				kconfig->indexKeyLength ) ;
		ap_rprintf( r, "<tr><td>Data Offset Start</td><td>%d</td></tr>\n", 
				kconfig->offsetStart ) ;
		ap_rprintf( r, "<tr><td>Data Offset Length</td><td>%d</td></tr>\n", 
				kconfig->offsetLength ) ;
		ap_rprintf( r, "<tr><td>Data Length Start</td><td>%d</td></tr>\n", 
				kconfig->dataLengthStart ) ;
		ap_rprintf( r, "<tr><td>Data Length Length</td><td>%d</td></tr>\n", 
				kconfig->dataLengthLength ) ;
		ap_rprintf( r, "<tr><td>Override Data Length</td><td>%d</td></tr>\n", 
				kconfig->dataOverrideLength ) ;
		ap_rprintf( r, "<tr><td>noDups</td><td>%d</td></tr>\n", 
				kconfig->noDuplicates ) ;
		ap_rprintf( r, "<tr><td>Result Pre Text</td><td><pre>%s</pre></td></tr>\n", 
				kconfig->resultPreText ) ;
		ap_rprintf( r, "<tr><td>Result Post Text</td><td><pre>%s</pre></td></tr>\n", 
				kconfig->resultPostText ) ;
		ap_rprintf( r, "<tr><td>Record Pre Text</td><td><pre>%s</pre></td></tr>\n", 
				kconfig->recordPreText ) ;
		ap_rprintf( r, "<tr><td>Record Post Text</td><td><pre>%s</pre></td></tr>\n", 
				kconfig->recordPostText ) ;
		ap_rprintf( r, "</table>\n" ) ;

		ap_rprintf( r, "<h2>Request information</h2>\n" ) ;
		ap_rprintf( r, "<table>\n" ) ;
		ap_rprintf( r, "<tr><td>Handler</td><td>%s</td></tr>\n", r->handler ) ;
		ap_rprintf( r, "<tr><td>Key</td><td>%s</td></tr>\n", key ) ;
		ap_rprintf( r, "<tr><td>Debug Mode</td><td>%s</td></tr>\n", debugMode ) ;
		ap_rprintf( r, "<tr><td>URI</td><td>%s</td></tr>\n", r->uri ) ;
		ap_rprintf( r, "<tr><td>path_info</td><td>%s</td></tr>\n", r->path_info ) ;
		ap_rprintf( r, "</table>\n" ) ;
		
		if (r->args)  /* Lastly, if there was a query string, let's print that too! */ 
			ap_rprintf(r, "Query string: %s\n", r->args);
	}

	search = searchFile( key, r, debug ) ;
	if ( debug ) {
		clock_gettime( CLOCK_MONOTONIC, &end ) ;
		double diff = end.tv_sec - start.tv_sec ;
		diff +=  (end.tv_nsec - start.tv_nsec) / 1000000000.0;
		ap_rprintf( r, "\n<br/>Elapsed time %lf seconds", diff ) ;
	}
	if ( debug ) 
		ap_rputs("</html>\n", r) ;

	return search;
}
